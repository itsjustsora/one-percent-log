## 3.5 메모리를 할당할 때 저수준 계층에서 일어나는 일

| 키워드 | 의미 |
| --- | --- |
| 사용자 모드 | 프로그래머가 작성한 ‘일반적인’ 코드를 CPU가 실행할 때의 모드 |
| 커널 모드  | CPU가 운영 체제의 코드를 실행할 때의 모드 |
| 표준 라이브러리 | C++에서 저수준 계층 간의 차이가 있어도 같은 기능을 실행할 수 있게 해주는 도구. 시스템 호출로 운영 체제와 소통한다. |
| 시스템 호출 | 운영체제 서비스를 제공받기 위해 보내는 요청 |
| 가상 메모리 | 논리적인 메모리 공간 |

### 🤖 malloc

➀ 여유 메모리 조각을 검색하고 적절한 크기의 조각을 찾아 할당한다.

➁ 적절한 여유 메모리를 찾지 못하면

- brk 같은 `시스템 호출`을 통해 `커널 상태`로 전환하여 운영 체제의 `가상 메모리` 시스템이 힙 영역을 확장하는 작업을 시작한다.
- brk 실행이 종료되면 CPU가 사용자 모드로 전환되며 적절한 여유 메모리 조각을 찾아 반환한다.
- 이때, 운영체제는 **아직 실제 물리 메모리를 할당하지 않았을 수 있다.**

➂ 코드가 새로 요청된 메모리를 읽거나 쓰면 시스템 내에서 `페이지 누락 인터럽트(page fault interrupt)`가 발생한다.

➃ 이때 CPU는 커널 모드로 전환되며 운영 체제가 실제 물리 메모리를 할당한다.

- 페이지 테이블 내 가상 메모리와 실제 물리 메모리의 사상 관계가 설정된 후, CPU는 다시 사용자 모드로 돌아간다.

<aside>

🔉 malloc을 통해 빈번하게 메모리를 할당하고 해제하는 것은 시스템 성능에 영향을 미친다. 비교적 높은 성능이 필요한 시스템에서는 그 차이가 더 벌어진다.

</aside>

---

## 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까?

> 🤔 malloc을 사용하지 않고 메모리를 할당하고 해제할 수 없을까?
>

### 메모리 풀(memory pool)

메모리 풀은 한 번에 큰 메모리 조각을 요청하고 그 위에서 자체적으로 메모리 할당과 해제를 관리하는 방식으로 표준 라이브러리리와 운영 체제를 우회한다.

- 자체 메모리 풀을 구현하여 특정 객체를 재사용하게 할 수 있다.
- 사용자 요청 처리가 완료되는 시점에 요청된 메모리를 한꺼번에 해제할 수 있다.
- `LinkedList` 자료구조와 포인터를 사용해 여유 메모리 조각을 관리할 수 있다.

**[1] 메모리 풀과 malloc의 차이점**

|  | 메모리 풀  | 범용 메모리 할당자 |
| --- | --- | --- |
| 소속 계층 | 응용 프로그램 | 표준 라이브러리 |
| 사용 대상 | 특정 상황에서만 메모리 할당 성능을 최적화한다. | 범용 제품으로 어떤 상황에서도 사용할 수 있다. |

**[2] 다중 스레드 환경에서의 메모리 풀**

➀ 메모리 풀에 직접 잠금 보호를 적용한다.

- **장점** : `thread-safe` 하다.
- **단점** : 대량의 스레드가 메모리 할당과 해제를 요청하면 `race condition` 발생으로 인해 성능이 저하될 수 있다.

➁ 각 스레드마다 메모리 풀을 유지한다.

- 스레드 풀을 `thread local storage`에 넣어 각 스레드가 자신에게 속한 스레드 풀만 사용할 수 있게 한다.
- **장점** : 스레드 간 경쟁 문제를 해결할 수 있다.
- **단점** : 메모리의 수명 주기가 스레드를 넘어서 공유되면 어느 스레드가 해제해야 하는지 모호해지고, 부적절한 해제나 메모리 누수가 발생할 수 있다.

---

## 3.7 대표적인 메모리 관련 버그

**➀ 스택 넘침**

전달받은 버퍼 크기를 모르므로 쉽게 buffer overflow 오류가 발생할 수 있다.

```java
void buffer_overflow() {
	char buf[32];
	
	gets(buf);
	
	return;
}
```

**➁ 메모리 누수**

메모리를 요청한 후 바로 반환하는데, 해당 메모리는 프로세스가 종료되기 전까지는 다시 해제할 방법이 없어 메모리 누수가 일어난다. 결국 운영 체제가 강제로 프로세스를 종료하는 상황이 발생한다.

```java
void memory_leak() {
	int *p = (int *)malloc(sizeof(int));
	
	return;
}
```

- 자신의 개발 환경에 적합한 메모리 분석 도구를 활용해 문제를 해결하자.

---

## 3.8 왜 SSD는 메모리로 사용할 수 없을까?

**➀  CPU가 파일의 특정 바이트에 직접 접근할 방법이 없다.**

- 메모리는 바이트 단위로, 다이트 단위 주소 지정이 지원된다.
- SSD는 조각 단위로 데이터를 관리하며, 조각의 크기는 매우 다양하다.

**➁ SSD는 사용 수명 제한이 있다.**

- SSD에 기록한 데이터의 누적 크기가 커지면 문제가 발생할 수 있다.
- CPU는 프로그램을 실행할 때 대량의 메모리 읽기 및 쓰기 작업을 시행하기 때문에 SSD를 메모리로 사용하면 사용 수명 때문에 시스템에 병목 현상이 발생할 수 있다.