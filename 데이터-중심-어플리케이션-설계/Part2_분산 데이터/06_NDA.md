> 데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족하고 데이터를 `파티션`으로 쪼갤 필요가 있다.  
> 이 작업을 `샤딩`이라고 한다.

**각 DB에서 파티션을 지칭하는 용어**

| 샤드(shard) | 몽고DB, 엘라스틱서치, 솔라클라우드 |
| --- | --- |
| 리전(region) | HBase |
| 태블릿(tablet) | 빅테이블 |
| 브이노드(vnode) | 카산드라, 리악 |
| 브이버켓(vBucket) | 카우치베이스 |

<br>

**[개념 사전]**

| 단어 | 설명 |
| --- | --- |
| 파티셔닝 | 대용량 데이터베이스를 의도적으로 작은 단위로 쪼개는 방법 |

<br>

## 새롭게 알게된 점(NEW)

### 파티셔닝

> 파티션을 나눌 때는 보통 각 데이터 단위(레코드, 로우, 문서)가 하나의 파티션에 속하게 된다. 데이터가 여러 파티션을 동시에 건드리는 연산을 지원할 수도 있지만 결과적으로 각 파티션은 그 자체로 작은 데이터베이스가 된다.
> 
> ***파티셔닝을 하는***  
> 💡 **주된 이유** : `확장성`  
> 💡 **목적** : 데이터와 질의 부하를 노드 사이에 고르게 `분산`시키는 것

| 표현 | 의미 |
| --- | --- |
| 쏠렸다(skewed) | 파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 생기는 현상 |
| 핫스팟 | 불균형하게 부하가 높은 파티션 |
- 대용량 데이터셋이 여러 디스크에 분산될 수도 있고 질의 부하는 여러 프로세서에 분산될 수 있다.
- 각 노드에서 자신의 파티션에 해당하는 질의를 독립적으로 실행할 수 있으므로 노드를 추가하면 `질의 처리량`을 늘릴 수 있다.
- 어떤 한 파티션에 속한 레코드를 여러 다른 노드에 저장해서 `내결함성`을 보장할 수 있다.
- **핫스팟을 회피하는 방법**
    - 레코드를 할당할 노드를 무작위로 선택하면 고르게 분산된다. **but,** 모든 노드에 병렬적으로 질의를 실행해야 한다.
    - 키-값 데이터 모델을 사용해 기본키를 통해 레코드에 접근한다. 모든 항목이 알파벳 순으로 정렬되어 있다.

<br>

**[1] 종류**

|  | **범위 기준**                                                     | 키 기준 |
| --- |---------------------------------------------------------------| --- |
| 방법 | 각 파티션의 연속된 범위의 키를 할당하며, 정렬된 순서로 저장할 수 있다.                     | 해시 함수를 사용해 키를 할당하여 쏠림과 핫스팟 유발을 방지한다. |
| 장점 | - 범위 스캔이 쉬워진다.<br>- 키를 연쇄된 색인으로 간주해 질의 하나로 관련 레코드 여러 개를 읽어온다. | 키를 파티션 사이에 균일하게 분산시킨다.
|
| 단점 | 연속된 레코드에 접근할 시 핫스팟을 유발할 수 있다.                                 | 범위 질의를 모든 파티션에 전송해야 한다. |
| 특징 | 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞춰 조정해야 한다.                      | 파티션 경계는 크기가 동일하도록 나눌 수도 있고 무작위에 가깝게 선택할 수도 있다. |
- **키 기준 파티셔닝의 단점을 극복하는 방법**
  - 키의 첫 부분에만 해싱을 적용하고 남은 컬럼은 `연쇄된 색인`으로 사용해 범위 질의에 활용한다.
  - 요청이 많은 키라면 키의 시작이나 끝에 임의의 숫자를 붙여 레코드를 여러 파티션에 분산시킨다. but, 읽기 작업을 할 때 데이터를 조합하는 작업이 필요하다.
- *트레이드 오프를 꼼꼼히 따져보자!*

<br>

**[2] 보조 색인**

> 보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점이 있다. 보조 색인이 있는 데이터베이스를 파티셔닝하는 데 쓰이는 두 가지 방법을 알아보자.
>

**1️⃣ 문서 기준 보조 색인 파티셔닝**

- 각 파티션은 자신의 보조 색인을 유지하며 그 파티션에 속하는 문서만 담당한다. 다른 파티션에 어떤 데이터가 저장되는지는 신경 쓰지 않는다. (`지역 색인(local index)`)
- `스캐터/개더(scatter/gather)`: 특정한 색상이거나, 특정한 제조사가 만든 자동차를 찾기 위해서는 **모든 파티션으로 질의를 보내서 얻은 결과를 모두 모아야 한다.**
  - 질의를 병렬 실행하더라도 꼬리 지연 시간 증폭이 발생하기 쉽다.

**2️⃣ 용어 기준 보조 색인 파티셔닝**

- 모든 파티션의 데이터를 담당하는 전역 색인을 만들며, 색인을 파티셔닝할 때 용어 자체를 쓸 수도 있고 용어의 해시값을 사용할 수도 있다.
- **장점** : 읽기가 효율적이다.
  - 모든 파티션에 `스캐터/개더`를 실행할 필요 없이 원하는 용어를 포함하는 파티션으로만 요청을 보내면 된다.
- **단점** : 쓰기가 느리고 복잡하다.
  - 데이터베이스에 기록된 모든 문서에 바로 색인을 반영하기 위해서는 쓰기에 영향받는 모든 파티션에 걸친 `분산 트랜잭션`을 실행해야 하는데, 모든 데이터베이스에서 지원하지 않는다.
  - 대개 비동기로 갱신되므로 변경 사항이 색인에 반영되지 않았을 수도 있다.