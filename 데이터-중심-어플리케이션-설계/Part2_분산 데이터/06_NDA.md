> 데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족하고 데이터를 `파티션`으로 쪼갤 필요가 있다.  
> 이 작업을 `샤딩`이라고 한다.

**각 DB에서 파티션을 지칭하는 용어**

| 샤드(shard) | 몽고DB, 엘라스틱서치, 솔라클라우드 |
| --- | --- |
| 리전(region) | HBase |
| 태블릿(tablet) | 빅테이블 |
| 브이노드(vnode) | 카산드라, 리악 |
| 브이버켓(vBucket) | 카우치베이스 |

<br>

**[개념 사전]**

| 단어 | 설명 |
| --- | --- |
| 파티셔닝 | 대용량 데이터베이스를 의도적으로 작은 단위로 쪼개는 방법 |
| 사전 분할(pre-splitting) | 빈 데이터베이스에 초기 파티션 집합을 설정하는 것 (HBase, 몽고DB 제공) |
| 서비스 찾기(service discovery) | 분산 시스템에서 특정 서비스의 위치(IP 및 포트 등)를 동적으로 찾는 방법 |
| 파티션 인지(partition-aware) | 시스템이 데이터가 특정 파티션에 저장된다는 점을 알고 있으며, 요청을 해당 파티션으로 직접 라우팅하는 능력 |
<br>

## 새롭게 알게된 점(NEW)

### 파티셔닝

> 파티션을 나눌 때는 보통 각 데이터 단위(레코드, 로우, 문서)가 하나의 파티션에 속하게 된다. 데이터가 여러 파티션을 동시에 건드리는 연산을 지원할 수도 있지만 결과적으로 각 파티션은 그 자체로 작은 데이터베이스가 된다.
> 
> ***파티셔닝을 하는***  
> 💡 **주된 이유** : `확장성`  
> 💡 **목적** : 데이터와 질의 부하를 노드 사이에 고르게 `분산`시키는 것

| 표현 | 의미 |
| --- | --- |
| 쏠렸다(skewed) | 파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 생기는 현상 |
| 핫스팟 | 불균형하게 부하가 높은 파티션 |
- 대용량 데이터셋이 여러 디스크에 분산될 수도 있고 질의 부하는 여러 프로세서에 분산될 수 있다.
- 각 노드에서 자신의 파티션에 해당하는 질의를 독립적으로 실행할 수 있으므로 노드를 추가하면 `질의 처리량`을 늘릴 수 있다.
- 어떤 한 파티션에 속한 레코드를 여러 다른 노드에 저장해서 `내결함성`을 보장할 수 있다.
- **핫스팟을 회피하는 방법**
    - 레코드를 할당할 노드를 무작위로 선택하면 고르게 분산된다. **but,** 모든 노드에 병렬적으로 질의를 실행해야 한다.
    - 키-값 데이터 모델을 사용해 기본키를 통해 레코드에 접근한다. 모든 항목이 알파벳 순으로 정렬되어 있다.

<br>

**[1] 종류**

|  | **범위 기준**                                                     | 키 기준 |
| --- |---------------------------------------------------------------| --- |
| 방법 | 각 파티션의 연속된 범위의 키를 할당하며, 정렬된 순서로 저장할 수 있다.                     | 해시 함수를 사용해 키를 할당하여 쏠림과 핫스팟 유발을 방지한다. |
| 장점 | - 범위 스캔이 쉬워진다.<br>- 키를 연쇄된 색인으로 간주해 질의 하나로 관련 레코드 여러 개를 읽어온다. | 키를 파티션 사이에 균일하게 분산시킨다.
|
| 단점 | 연속된 레코드에 접근할 시 핫스팟을 유발할 수 있다.                                 | 범위 질의를 모든 파티션에 전송해야 한다. |
| 특징 | 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞춰 조정해야 한다.                      | 파티션 경계는 크기가 동일하도록 나눌 수도 있고 무작위에 가깝게 선택할 수도 있다. |
- **키 기준 파티셔닝의 단점을 극복하는 방법**
  - 키의 첫 부분에만 해싱을 적용하고 남은 컬럼은 `연쇄된 색인`으로 사용해 범위 질의에 활용한다.
  - 요청이 많은 키라면 키의 시작이나 끝에 임의의 숫자를 붙여 레코드를 여러 파티션에 분산시킨다. but, 읽기 작업을 할 때 데이터를 조합하는 작업이 필요하다.
- *트레이드 오프를 꼼꼼히 따져보자!*

<br>

**[2] 보조 색인**

> 보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점이 있다. 보조 색인이 있는 데이터베이스를 파티셔닝하는 데 쓰이는 두 가지 방법을 알아보자.

**1️⃣ 문서 기준 보조 색인 파티셔닝**

- 각 파티션은 자신의 보조 색인을 유지하며 그 파티션에 속하는 문서만 담당한다. 다른 파티션에 어떤 데이터가 저장되는지는 신경 쓰지 않는다. (`지역 색인(local index)`)
- `스캐터/개더(scatter/gather)`: 특정한 색상이거나, 특정한 제조사가 만든 자동차를 찾기 위해서는 **모든 파티션으로 질의를 보내서 얻은 결과를 모두 모아야 한다.**
  - 질의를 병렬 실행하더라도 꼬리 지연 시간 증폭이 발생하기 쉽다.

<br>

**2️⃣ 용어 기준 보조 색인 파티셔닝**

- 모든 파티션의 데이터를 담당하는 전역 색인을 만들며, 색인을 파티셔닝할 때 용어 자체를 쓸 수도 있고 용어의 해시값을 사용할 수도 있다.
- **장점** : 읽기가 효율적이다.
  - 모든 파티션에 `스캐터/개더`를 실행할 필요 없이 원하는 용어를 포함하는 파티션으로만 요청을 보내면 된다.
- **단점** : 쓰기가 느리고 복잡하다.
  - 데이터베이스에 기록된 모든 문서에 바로 색인을 반영하기 위해서는 쓰기에 영향받는 모든 파티션에 걸친 `분산 트랜잭션`을 실행해야 하는데, 모든 데이터베이스에서 지원하지 않는다.
  - 대개 비동기로 갱신되므로 변경 사항이 색인에 반영되지 않았을 수도 있다.

<br>

**[3] 파티션 재균형화**

> **<데이터베이스의 변화>**
> - 질의 처리량이 증가해서 늘어난 부하를 처리하기 위해 CPU를 더 추가하고 싶다.
> - 데이터셋 크기가 증가해서 데이터셋 저장에 사용할 디스크와 램을 추가하고 싶다.
> - 장비에 장애가 발생해서 그 장비가 담당하던 역할을 다른 장비가 넘겨받아야 한다.
> 
> 데이터베이스에 변화가 생겼을 때 데이터와 요청이 한 노드에서 다른 노드로 옮겨져야 한다. 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 `재균형화(rebalancing)`라고 한다.
>

**1️⃣ 최소 요구사항**

- 재균형화 후, 부하(데이터 저장소, 읽기 쓰기 요청)가 클러스터 내에 있는 노드들 사이에 균등하게 분배돼야 한다.
- 재균형화 도중에도 데이터베이스는 읽기 쓰기 요청을 받아들여야 한다.
- 재균형화가 빨리 실행되고 네트워크와 디스크 I/O 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안 된다.

<br>

**2️⃣ 전략**

1. **모드 연산은 하지 말자**. 노드의 수(N)가 늘어날 때마다 키의 위치를 변경해야 한다. `(hash(key) % N)`
2. **파티션을 노드의 수보다 많이 만들고 각 노드에 여러 파티션을 할당**한다. 파티션은 노드 사이에서 통째로 이동하기만 하면 된다.
3. **동적 파티셔닝**을 이용하자. 파티션 개수가 전체 데이터 용량에 맞춰 조정된다.
4. **파티션 개수가 노드 대수에 비례**하게 만들자. 데이터 용량이 클수록 데이터를 저장할 노드도 많이 필요하므로 이 방법을 쓰면 개별 파티션 크기도 상당히 안정적으로 유지된다.

<br>

**3️⃣ 자동 및 수동 재균형화**

> 🤔 재균형화는 자동으로 실행될까, 아니면 수동으로 실행해야 할까?
>

| 종류 | 완전 자동 재균형화 | 완전 수동 재균형화 |
| --- | --- | --- |
| 장점 | 유지보수성이 확보되어 편리하다. | 운영상 예기치 못한 일을 방지할 수 있다. |
| 단점 | 주의 깊게 처리하지 않으면 네트워크나 노드에 과부하가 걸리거나 다른 요청의 성능이 저하될 수 있다. | 완전 자동 처리보다 속도가 느리다. |

<br>

**[4] 요청 라우팅**

> 🤔 파티션이 재균형화되면서 노드에 할당되는 파티션이 바뀌는데, 클라이언트에서 요청을 보내려고 할 때 어느 노드로 접속해야 하는지 어떻게 알 수 있을까?
>

<img width="602" alt="Image" src="https://github.com/user-attachments/assets/729b2832-5243-4b23-a90f-b395b5a2b3ad" />

1. **아무 노드에나 접속**하게 한다. 요청을 적용할 파티션이 있다면 직접 처리하고, 그렇지 않으면 올바른 노드로 전달해서 응답을 받는다.
2. **라우팅 계층으로 먼저 보내** 각 요청을 처리할 노드를 알아내고 전달한다.
3. **파티셔닝 방법과 파티션이 어떤 노드에 할당됐는지 알고 있게** 한다.

<br>

**1️⃣ 코디네이션 서비스**

> 많은 분산 데이터 시스템은 클러스터 메타데이터를 추적하기 위해 `주키퍼(ZooKeeper)` 같은 별도의 코디네이션 서비를 사용한다.

| 이름 | 설명 |
| --- | --- |
| Zookeeper | 파티션 소유자가 바뀌든지, 노드가 추가되거나 삭제되면 주키퍼는 라우팅 계층에 이를 알려서 라우팅 정보를 최신으로 유지할 수 있게 한다. *(헬릭스, HBase, 솔라클라우드, 카프카 사용)* |
| MongoDB | 자체적인 `설정 서버(config server)` 구현에 의존하고 `몽고스(mongos)` 데몬을 라우팅 계층으로 사용한다. |
| 가십 프로토콜(gossip protocol) | 클러스터 상태 변화를 노드 사이에 퍼뜨려, 아무 노드나 요청을 받을 수 있고 요청을 받은 노드는 요청을 처리할 파티션을 갖고 있는 올바른 노드로 요청을 전달해준다. (*카산드라, 리악 사용)* |
| 카우치베이스 | 재균형화를 자동으로 실행하지 않으며, 클러스터 노드로부터 변경된 라우팅 정보를 알아내는 `목시(moxi)`라는 라우팅 계층을 설정한다. |

<br>

**2️⃣ 병렬 질의 실행**

> 분석용으로 자주 사용되는 `대규모 병렬 처리(massively parallel processing, MPP)` 관계형 데이터베이스 제품은 훨씬 더 복잡한 종류의 질의를 지원한다.
>
- MPP 질의 최적화기는 복잡한 질의를 여러 실행 단계와 파티션으로 분해하며, 이들 중 다수는 데이터베이스 클러스터 내의 서로 다른 노드에서 병렬적으로 실행될 수 있다.

<br>

## 어려웠거나 이해하지 못한 부분(Difficulty)

<br>

## 추가 내용(Amendment)

**참고.** [[DB] 파티셔닝? 샤딩? 레플리케이션?](https://youtu.be/P7LqaEO-nGU?si=U3ZW1sTkDBM-iQE9)

<br>

### 파티셔닝의 종류

> 파티셔닝은 테이블을 목적에 따라 작은 테이블로 나누는 방식이다.

| 종류 | 수직(vertical) 파티셔닝 | 수평적(horizontal) 파티셔닝 |
| --- | --- | --- |
| 특징 | 컬럼을 기준으로 테이블을 나누는 방식 | row를 기준으로 테이블을 나누는 방식 |

<br>

**1️⃣ 수직 파티셔닝 이해하기**

***파티셔닝 전***

`article`이라는 테이블에는 총 7개의 컬럼이 있다. 게시글의 목록을 조회할 때 `content` 컬럼을 제외한 나머지 컬럼을 조회할 것이다.

<img width="610" alt="Image" src="https://github.com/user-attachments/assets/011e9abf-e886-41d0-88b9-ad3d82678258" />

```sql
SELECT id, title, writer_id, read_cnt, comment_cnt, created_at
FROM article
WHERE ...
```

- 해당 쿼리문을 실행하면 우선 조건문에 해당하는 여러 row의 **모든 컬럼 정보를** 메모리에 적재한 후에, `content`를 필터링 하여 결과를 반환한다.
- 어떤 경우에는, 가장 데이터가 많고 필요하지 않은 content 정보를 메모리에 적재하기 위한 I/O 부담이 발생할 수 있다.

<br>

***파티셔닝 후***

<img width="610" alt="Image" src="https://github.com/user-attachments/assets/33c68e08-0c8c-424b-a9b2-b60228bfdeee" />

- `content` **컬럼을 담은 테이블을 따로 분리**하여 게시글 **목록 조회**에는 `article`, **상세 조회**에는 `article_content` **테이블을 활용**한다.

```text
📝 NOTE. 그외에도 보안이 중요한 데이터들은 다른 테이블로 분리하거나, 
자주 사용되는 컬럼들과 사용되지 않는 컬럼들을 분리할 수도 있다.
```

<br>

**2️⃣ 수평 파티셔닝 이해하기**

- 테이블의 크기가 커질수록 인덱스도 커진다.
- 테이블에 읽기, 쓰기 작업이 일어날 때마다 인덱스에서 처리되는 시간도 조금씩 늘어난다.
- id를 기준(`partition key`)으로 해시 기반 혹은 범위 기반의 수평 파티셔닝을 수행한다. (**스키마는 동일**)

<br>

```text
📝 NOTE. 가장 많이 사용될 패턴에 따라 `partition key`를 정하는 것이 중요하다. 
적용되지 않은 컬럼으로 조회하면 분리된 모든 테이블을 조회해야 하기 때문이다. 
또한 데이터가 균등하게 분배될 수 있도록 해시 함수를 잘 정의하는 것도 잊지 말자!
```

<br>

### 샤딩(sharding)

> 🤔 그렇다면 파티셔닝과 샤딩은 어떤 차이점이 있을까?
>
- `샤딩`은 `horizontal partitioning(row 기준)` 처럼 동일한 방식으로 동작하며, **분리된 파티션들이 각각 독립된 서버에 저장된다**는 차이점이 있다.
- 부하를 분산하는 데 유리하다.
- 이때는 partition key를 `shard key`, 각 파티션을 `shard`라고 부른다.