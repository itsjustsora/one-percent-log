> *이봐 방금 널 만났어  
네트워크가 느려터졌군  
하지만 여기 내 데이터가 있으니  
아마도 저장해주길*  
> 
> 카일 킹스베리, 칼리 레이 젭슨과 네트워크 분단의 위험성(2013)
- 이번 장에서는 현업에서 일어나는 문제점들을 맛보고, 우리가 기댈 수 있는 것과 그렇지 않은 것을 이해하게 된다.
- 결국 엔지니어로서의 우리의 임무는 모든 게 잘못되더라도 제 역할을 해내는 시스템을 구축하는 것이다.
- 분산 시스템의 상태에 대해 생각하는 방법과 무슨 일이 일어났는지 추론하는 방법을 알아보자!

<br>

**[단어 사전]**

| 단어 | 의미 |
| --- | --- |
| 비동기 패킷 네트워크(asynchronous packet network) | 네트워크에서 패킷이 고정된 시간 간격 없이 비동기적으로 전송되는 방식 |
| 네트워크 분단(network partition) or 네트워크 분리(netsplit) | 네트워크 결함으로 인해 네트워크 일부가 다른 쪽과 차단되는 현상 |
| 기약 없는 지연(unbounded delay) | 패킷이 도착하는 데 걸리는 시간에 상한치가 없는 개념 |
| 흐름 제어(flow control) | 노드가 네트워크 링크나 수신 노드에 과부하를 가하지 않도록 자신의 송신율을 제한하는 것 |
| 혼잡 회피(congestion avoidance) | 네트워크가 혼잡해지기 전에 트래픽을 조절하는 기법 |
| 배압(backpressure) | 네트워크 또는 시스템에서 처리 속도를 제어하기 위해 데이터를 일시적으로 지연시키는 기법 |
| 경계 경로 프로토콜(BGP, Border Gateway Protocol) | 인터넷 상의 자율 시스템(AS, Autonomous System) 간 경로를 결정하는 라우팅 프로토콜(글로벌 네트워크에서 최적의 데이터 전송 경로를 찾는 역할) |
| 지터(jitter) | 네트워크 지연(latency)이나 응답 시간(response time)이 일정하지 않고 변동하는 현상 |
| 시계 드리프트(drift) | 컴퓨터의 시계가 더 빠르거나 느리게 실행되는 현상 |
| 윤초(leap seconds) | 지구의 자전 속도와 국제 표준시(UTC) 간의 오차를 보정하기 위해 추가 또는 제거하는 1초 |
| 플래시 크래시(flash crashes) | 주가나 채권 금리가 급락하는 상황 |

<br>

## 새롭게 알게된 점(NEW)

### 결함과 부분 장애

- 단일 컴퓨터에서 실행되는 소프트웨어를 믿지 못할 근본적인 이유는 없다. 하드웨어가 올바르게 동작하면 같은 연산은 항상 같은 결과를 낸다.
- 분산 시스템에서는 더 이상 이상화된 시스템 모델에서 동작하지 않는다.
- `부분 장애(partial failure)` : 시스템의 어떤 부분은 잘 동작하지만 다른 부분은 예측할 수 없는 방식으로 고장나는 것 (비결정적)
- ***비결정성**과 **부분 장애 가능성**이 분산 시스템을 다루기 어렵게 한다.*

<br>

### 신뢰성 없는 네트워크

> 이 책에서 주로 다루는 분산 시스템은 비공유 시스템, 즉 네트워크로 연결된 다수의 장비다.
>
- 특별한 하드웨어가 필요하지 않아서 상대적으로 저렴하다.
- 상품화된 클라우드 서비스를 활용할 수 있다.
- 지리적으로 분산된 여러 데이터센터에 중복 배치함으로써 높은 신뢰성을 확보할 수 있다.

하지만, `비동기 패킷 네트워크(asynchronous packet network)`이므로 메시지의 도착을 보장하지 않는다는 문제점이 있다. `타임아웃`으로 처리할 수 있지만 시간이 지나 메시지가 수신 측에 도착할 수도 있다.

<br>

**[1] 현실의 네트워크 결함**

> 네트워크 결함이 드물더라도 결함이 일어날 수 있다는 사실은 여러분의 소프트웨어가 이를 처리할 수 있어야 한다는 뜻이다. 네트워크 상으로 통신할 때마다 실패할 가능성이 있다. 피할 방법은 없다.
>
- 반드시 네트워크 결함을 견뎌내도록(tolerating) 처리할 필요는 없다.
- 네트워크가 평상시에는 믿을 만하다면 네트워크에 문제가 생겼을 때 사용자에게 오류 메시지를 보여주는 것도 괜찮다.

<br>

**[2] 타임아웃과 기약 없는 지연**

> 타임아웃만이 결함을 감지하는 확실한 수단이라면 타임아웃은 얼마나 길어야 할까? 유감스럽게도 간단한 답은 없다.
>
- 타임아웃이 길면, 노드가 죽었다고 선언될 때까지 기다리는 시간이 길어진다.
- 타임아웃이 짧으면, 결함은 빨리 발견하지만 노드가 일시적으로 느려졌을 뿐인데도 죽었다고 잘못 선언한 위험이 높아진다.
- 비동기 네트워크는 `기약 없는 지연(unbounded delay)`이 있고, 서버 구현은 대부분 어떤 최대 시간 내에 요청을 처리한다고 보장할 수 없다.

<br>

**[3] 네트워크 혼잡과 큐 대기**

> 컴퓨터 네트워크에서 패킷 지연의 변동성은 큐 대기 때문인 경우가 많다.
>


- `네트워크 혼잡(network congestion)` : 네트워크 링크가 붐벼 패킷이 슬롯을 얻을 수 있을 때까지 기다려야 하는 현상
- 네트워크는 잘 동작하고 있더라도 들어오는 데이터가 많아서 스위치 큐를 꽉 채울 정도가 되면 패킷이 유실되어 재전송해야 한다.
- 패킷이 목적지 장비에 도착했다고 하더라도 CPU 코어가 당장 처리하지 못한다면, 운영체제가 큐에 넣어 둔다. 장비의 부하에 따라 큐에서 대기하는 시간이 달라진다.
- 가상 환경에서 실행되는 운영체제는 다른 가상 장비가 CPU 코어를 사용하는 동안 수십 밀리초 동안 멈출 때가 흔하다.

<br>

1️⃣ **TCP**

- `흐름 제어`를 수행하기 때문에, 데이터가 네트워크로 들어가기 전에도 부가적인 큐 대기가 이루어질 수 있다.
- 타임아웃 안에 확인 응답을 받지 않으면 패킷 손실을 예상하고 자동으로 `재전송`한다. 이때 지연이 발생한다.

<br>

2️⃣ 해결 방법

❶ `지연의 변동성`을 알아내기 위해 긴 기간에 여러 장비에 걸쳐 `네트워크 왕복 시간의 분포`를 **측정**한다. 이후에 애플리케이션의 특성을 고려해서 장애 감지 지연과 이른 타임아웃의 위험성 사이에서 적절한 트레이드오프를 결정한다.

❷ 시스템이 지속적으로 응답 시간과 그들의 변동성을 측정하고 관찰된 응답 시간 분포에 따라 타임아웃을 자동으로 조절하게 한다.

- 이때 `파이 증가 장애 감지기(Phi accrual failure detector)`를 사용한다. **아카(Akka)**와 **카산드라**가 이를 사용하며, TCP 재전송 타임아웃도 비슷하게 동작한다.

<br>

**[4] 동기 네트워크 대 비동기 네트워크**

> 패킷 전송 지연 시간의 최대치가 고정돼 있고 패킷을 유실하지 않는 네트워크에 기댈 수 있다면 분산 시스템은 훨씬 더 단순해진다. *왜 하드웨어 수준에서 이 문제를 해결하고 네트워크를 신뢰성 있게 만들어서 소프트웨어에서는 걱정할 필요가 없게 할 수 없을까?*
>
- 전화 네트워크에서 통화를 할 때는 `회선(circuit)`이 만들어진다. 통화를 하는 두 명 사이에 있는 전체 경로를 따라서 그 통화에 대해 고정되고 보장된 양의 대역폭이 할당된다. 회선은 통화가 끝날때까지 유지된다.
- 전화 네트워크의 경우 `동기식`이다. 데이터가 여러 라우터를 거치더라도 큐 대기 문제를 겪지 않는다.
    - 네트워크의 다음 `홉(hop)`에 통화당 16비트의 공간이 이미 할당됐기 때문이다.
    - 큐 대기가 없으므로 `네트워크 종단 지연 시간의 최대치`가 **고정**돼 있다.
    - 이를 `제한 있는 지연(bounded delay)`라고 한다.

<br>

**1️⃣ 왜 데이터센터 네트워크와 인터넷은 패킷 교환을 사용할까?**

- `순간적으로 몰리는 트래픽(bursty traffic)`에 **최적화**됐기 때문이다.
    - 순간적으로 몰리는 데이터 전송에 회선을 쓰면 네트워크 용량을 낭비하고 전송이 불필요하게 느려진다.
- 반대로 `TCP`는 **가용한 네트워크 용량**에 맞춰 **데이터 전송률**을 **동적으로 조절**한다.