## 04. 부호와와 발전
> `복제`란 **네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지**한다는 의미다.
복제에서 모든 어려움은 복제된 데이터의 **변경** 처리에 있으며 이것이 이번 장의 내용이다.
데이터 복제가 필요한 여러 이유가 있다.
>
- 지리적으로 사용자와 가깝게 데이터를 유지해 `지연 시간`을 줄인다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 `가용성`을 높인다.
- 읽기 질의를 제공하는 장비의 수를 `확장`해 `읽기 처리량`을 늘린다.

<br>

**[개념 사전]**

| 단어 | 의미 |
| --- | --- |
| 최종적 일관성 | 분산 시스템에서 즉각적인 일관성을 보장하지 않지만, 일정 시간이 지나면 결국 일관된 상태에 도달하는 특성 |
| 복제 서버(replica) | 데이터베이스의 복사본을 저장하는 각 노드 |
| 리더 기반 복제(leader-based replication)(=능동(active)/수동(passive), 마스터(master) 슬레이브(slave) 복제) | 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 로그나 스트림으로 팔로워에게 전송하면, 팔로워가 로컬 복사본을 갱신하는 방법 |
| 구문 기반 복제(statement-based replication) | 리더가 모든 쓰기 요청을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송해 팔로워가 갱신하는 방법 |
| 논리적 로그(logical log) | 대개 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드 열 |
| 변경 데이터 캡처(CDC, change data capture) | 데이터베이스의 변경 사항을 감지하고 실시간으로 추출하여 다른 시스템으로 전달하는 기술 |
| 읽기 확장(read-scaling) 아키텍처 | 많은 팔로워를 만들어 팔로워 간 읽기 요청을 분산하여 리더의 부하를 없애고 근처 복제 서버에서 읽기 요청을 처리할 수 있게 구성하는 방법 |
| 최종 쓰기 승리(LWW, last write wins) | 분산 시스템에서 동일한 데이터에 대한 충돌이 발생할 때, 가장 나중에 기록된 값을 최종적으로 유지하는 충돌 해결 전략 |
| 이중 병합 함수(two-way merge function) | 연산 순서와 관계없이 동일한 결과를 보장하는 병합 함수 |
| 삼중 병합 함수(three-way merge function) | 연산의 그룹화 방식이 달라도 결과가 동일한 병합 함수 (Git에서 브랜치 병합 시 공통 조상을 기준으로 병합 연산 수행) |

<br>

## 새롭게 알게된 점(New)

### 리더 기반 복제

**[1] 동기식 vs. 비동기식**

> `반동기식(semi-synchronous)`
현실적으로 데이터베이스에서 동기식 복제를 사용하려면 보통 팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하는 것을 의미한다. 적어도 두 노드에 데이터의 최신 복사본이 있는 것을 보장할 수 있다.
>
- 보통 리더 기반 복제는 완전히 비동기식으로 구성한다.
- **단점** : 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다.
- **장점** : 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있다.

<br>

**[2] 새로운 팔로워 설정 프로세스**

1. 리더의 데이터베이스 `스냅샷`을 일정 시점에 가져온다.
2. `스냅샷`을 새로운 팔로워 노드에 `복사`한다.
3. 팔로워는 리더에 연결해 스냅샷 이후 발생한 모든 `데이터 변경`을 요청한다.
4. 팔로워가 스냅샷 이후 데이터 변경의 `미처리분(backlog)`을 모두 처리했을 때 따라잡았다고 말하며, 이제부터 리더에 발생하는 데이터 변화를 이어 처리할 수 있다.

<br>

**[3] 고가용성 달성 방법**

1️⃣ **팔로워에 장애가 일어났을 경우**

- 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관한다.
- 보관된 로그에서 결함이 발생하기 전 마지막으로 처리한 트랜잭션 이후의 데이터 변경을 요청할 수 있다.

<br>

2️⃣ **리더에 장애가 일어났을 경우**

> `장애 복구(failover)` 과정  
→ *팔로워 중 하나를 새로운 리더로 승격*한다.  
→ 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정한다.  
→ 다른 팔로워는 새로운 리더로부터 데이터 변경 소비하기 시작한다.
>
- 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신하지 못할 수 있다.
    - **일반적인 해결책** : 이전 리더의 복제되지 않은 쓰기를 단순히 폐기하자. (이 방법은 내구성에 대한 클라이언트의 기대를 저버리게 된다.)
- 쓰기를 폐기하는 방법은 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야 한다면 위험하다.
- `스플릿 브레인(split brain)` : 두 노드가 모두 자신이 리더라고 믿는 현상 (데이터가 유실되거나 오염되게 됨)

<br>

**[4] 복제 로그 구현**

| 종류 | **WAL Shipping**                                                                                                                                                         | **논리적(로우 기반) 로그 복제** | **트리거 기반 복제** |
| --- |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------| --- | --- |
| 특징 | 1️⃣ **저장소 엔진과 밀접한 연관성** ⭕️<br> `WAL`는 어떤 디스크 블록에서 어떤 바이트를 변경 했는지와 같은 상세 정보를 포함하므로 복제가 저장소 엔진과 밀접하게 엮인다.<br>2️⃣ **중단 시간 필요**<br> 복제 프로토콜이 버전의 불일치를 허용하지 않으므로 업그레이드할 때 중단 시간이 필요하다. | 1️⃣ **저장소 엔진과 밀접한 연관성** ❌<br> 하위 호환성을 더 쉽게 유지할 수 있으며, 리더와 팔로워에서 다른 버전의 데이터베이스 혹은 다른 저장소 엔진을 실행할 수 있다.<br> 2️⃣ **외부 애플리케이션의 파싱 용이성 확보**오프라인 분석이나 사용자 정의 색인과 캐시 구축을 위해 데이터 웨어하우스 같은 외부 시스템에 데이터베이스의 내용을 전송하고자 할 때 유용하다. | 1️⃣ **유연성 확보**<br> 데이터베이스 서브셋만 복제, 다른 종류의 데이터베이스로 복제, 충돌 해소 로직이 필요할 때 복제를 애플리케이션 층으로 옮겨 실행할 수 있다.<br>2️⃣ **많은 오버헤드, 버그 발생**<br> 다른 복제 방식보다 많은 오버헤드, 버그나 제한 사항이 더 많이 발생한다.|
**트리거 기반 복제에 사용되는 기술**
- 오라클의 `골든게이트(GoldenGate)` : 데이터베이스 로그를 읽어 애플리케이션이 데이터를 변경할 수 있게 한다.
- **트리거 기반** : ORACLE `데이터버스(Databus)`, PostgreSQL `부카르도(Bucarde)`

<br>

**[5] 복제 지연이 있을 때 발생할 수 있는 세 가지 사례와 해결 방법**

> **🧐 문제 1.** 사용자가 쓰기를 수행한 직후 데이터를 본다면 새로운 데이터는 아직 복제 서버에 반영되지 않아 제출된 데이터가 유실된 것처럼 보인다.
>
- **해결 방법**
    - **`쓰기 후 읽기 일관성` :** 사용자가 페이지를 재로딩 했을 때 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장하며 다른 사용자에 대해서는 보장하지 않는다.
- **프로세스**
    - 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다.
    - 마지막 갱신 후 1분 동안은 리더에서 모든 읽기를 수행한다.
    - 복제 서버가 아직 최신 내용이 아닌 경우 다른 복제 서버가 읽기를 처리하거나 복제 서버가 따라잡을 때까지 질의를 대기시킨다.

<br>

<div style="
  padding: 16px; 
  border: 1px solid #ddd; 
  border-radius: 8px;
">
  <strong>🔉 디바이스 간(cross-device) 쓰기 후 일관성</strong>
  <li>마지막 갱신 타임스탬프와 같은 메타데이터는 `중앙집중식`으로 관리한다.</li>
  <li>사용자 디바이스의 요청을 동일한 데이터센터로 라우팅해야 한다. (데스크톱 컴퓨터는 홈 광대역 연결, 모바일 디바이스는 셀룰러 데이터 네트워크를 이용한다면 네트워크 라우팅이 완전히 다름)</li>
</div>

<br>

> **🧐 문제 2**. 사용자가 새로운 데이터를 조회했음에도 다음 질의에서는 이전 데이터를 조회한다.

<img width="501" alt="Image" src="https://github.com/user-attachments/assets/acc27c6e-cd96-4515-bb3e-c12af79e52cc" />

- **해결 방법**
    - **`단조 읽기`** : 이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않는다.
- **프로세스**
    - 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것이다.
    - 임의 선택보다는 `사용자 ID의 해시`를 기반으로 복제 서버를 선택한다.
    - 복제 서버가 고장 나면 사용자 질의를 다른 복제 서버로 재라우팅해야 한다.

<br>

> **🧐 문제 3**. 사용자가 데이터베이스에서 읽을 때 예전 상태의 일부와 새로운 상태의 일부를 함께 볼 수 있다.
>

<img width="534" alt="Image" src="https://github.com/user-attachments/assets/2344a615-06e0-4c48-96f9-9800fab0b3c0" />

- **해결 방법**
    - **`일관된 순서로 읽기`** : 일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장한다. (서로 다른 파티션이 독립적으로 동작해 쓰기의 전역 순서가 없어 발생하는 것!)
- **프로세스**
    - 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 한다. (일부 애플리케이션에서 효율적이지 않음)

<br>

### 다중 리더 복제

> 리더가 하나만 존재하고 모든 쓰기는 해당 리더를 거쳐야 할 때, 모종의 이유로 리더에 연결할 수 없다면 문제가 발생한다.
이 문제를 해결하기 위해 쓰기를 허용하는 노드를 하나 이상 두고 각 노드는 데이터 변경을 다른 모든 노드에 전달한다.
>
- 동일한 데이터를 다른 두 개의 데이터센터에서 동시에 변경하려고 한다면 `쓰기 충돌`이 발생한다.
- 새로 추가된 기능이기 때문에 자동 증가 키, 트리거, 무결성 제약 등의 기능들이 불안정하다.

<br>

**[1] 실시간 협업 편집 애플리케이션** (`e.g.` Google Docs)

- 변경 내용을 즉시 로컬 복제 서버에 적용하고 동일한 문서를 편집하는 다른 사용자와 서버에 비동기 방식으로 복제한다.
- 빠른 협업을 위해 변경 단위를 단일 키 입력과 같이 매우 작게 해서 잠금을 피할 수 있다.

<br>

**[2] 쓰기 충돌**

- **충돌 회피** : 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 보장한다.
- **일관된 상태 수렴** : 모든 변경이 복제돼 모든 복제 서버에 동일한 최종 값이 전달되게 한다.
- **충돌 해소 로직 작성** : 대부분의 다중 리더 복제 도구를 애플리케이션 코드를 사용해 충돌 해소 로직을 작성한다.
    - 충돌 해소는 보통 전체 트랜잭션이 아니라 개별 로우나 문서 수준에서 적용된다.

<br>

<div style="
  padding: 16px; 
  border: 1px solid #ddd; 
  border-radius: 8px;
">
  <strong>🔉 충돌을 자동으로 해소하는 흥미로운 연구 내용</strong>
  <li><b>충돌 없는 복제 데이터타입(CRDT, conflict-free replicated datatype)</b> : Set, Map, 정렬 목록, 카운터 등을 위한 데이터 구조의 집합으로 동시에 여러 사용자가 편집할 수 있고 합리적인 방법으로 충돌을 자동 해소한다.</li>
  <li><b>병합 가능한 영속 데이터 구조(mergeable persistent data structure)</b> : Git 버전 제어 시스템과 유사하게 명시적으로 히스토리를 추적하고 삼중 병합 함수(three-way merge fuction)을 사용한다.</li>
  <li><b>운영 변환(operational transformation)</b> : 협업 편집 애플리케이션의 충돌 해소 알고리즘이다. 특히 텍스트 문서를 구성하는 문자 목록과 같은 정렬된 항목 목록의 동시 편집을 위해 설계됐다.</li>
</div>



