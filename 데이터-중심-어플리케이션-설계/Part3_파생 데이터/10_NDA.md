> 한 사람의 영향도가 너무 큰 시스템은 성공하기 어렵다. 초기 설계가 완료되고 상당히 견고해지면 여러 사람이 다양한 관점을 가지고 각각 실험을 진행하면서 실제 테스트가 시작된다.
- 도널드 크누스
>

**[세 가지 유형의 시스템]**

|  | 서비스(온라인 시스템) | 일괄 처리 시스템
(오프라인 시스템) | 스트림 처리 시스템
(준실시간 시스템) |
| --- | --- | --- | --- |
| 설명 | 서비스는 클라이언트로부터 요청이나 지시가 올 때까지 기다린다. | 매우 큰 입력 데이터를 받아 데이터를 처리하는 작업을 수행하고 결과 데이터를 생산한다. | 요청에 대해 응답하지 않으며 입력 데이터를 소비하고 출력 데이터를 생산한다. |
| 주요 성능 지표 | 응답 시간, 가용성 | 처리량(입력 데이터 중 특정 크기만큼 처리할 때 걸리는 시간) |  |
- 일괄 처리는 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션을 구축하는 데 매우 중요한 구성요소다.
- 일괄 처리 알고리즘인 맵리듀스(MapReduce)로 왜 일괄 처리가 유용한지 명확하게 그림을 그려보고 이해해 보자.

**[유닉스 명령어]**

| 명령어 | 설명 | 예제                                                                                                                                        |
| --- | --- |-------------------------------------------------------------------------------------------------------------------------------------------|
| awk | 텍스트 파일에서 특정 필드나 패턴을 추출하거나 조작 | 두 번째 필드만 출력<br> `awk ‘{pring $2}’ file.txt`                                                                                               |
| sed | 파일이나 입력 스트림에서 문자열 치환, 삭제, 삽입 등의 작업 수행 | 모든 ‘apple’를 ‘orange’로 치환 <br>`sed ‘s/apple/orange/g’ file.txt`                                                                            |
| grep | 특정 문자열이나 정규표현식을 포함한 줄 검색 | 대소문자 구분 없이 검색<br>`grep -i ‘hello’ file.txt`                                                                                               |
| sort | 줄 단위로 데이터 정렬 (숫자, 역순, 특정 필드 기준) | 숫자 기준 정렬<br>`sort -n numbers.txt`                                                                                                         |
| uniq | 연속된 중복 줄 제거 (sort와 함께 사용해야 정확) | 중복 제거<br>`sort file.txt \| uniq`                                                                                                          |
| xargs | 파이프로 전달된 결과를 인수로 변환해 명령어 실행에 사용 | 파일 목록을 인수로 받아 삭제<br>`ls rm *.log \| xargs rm`                                                                                             
| head | 파일의 처음 몇 줄 출력 (기본: 10줄) | 앞의 5줄만 출력<br>                                                                                              `head -n 5 file.txt`           |
| less | 텍스트 파일을 한 페이지씩 보면서 스크롤, 검색 | 로그 파일 보기<br>                                                                                                       `less /var/log/syslog` |

<br>

[개념 사전]

| 단어 | 설명 |
| --- | --- |
| 발칸화(Balkanization) | 인터넷이 고립된 여러 개의 섬처럼 나뉘어 있는 현상이나 프로그램 언어나 데이터 파일 포맷 등이 분화발전하는 것 |

<br>

## 새롭게 알게 된 점(New)

### 유닉스 도구로 일괄 처리하기

**[1] 단순 로그 분석**

`sort` 유틸리티는 메모리보다 큰 데이터셋을 자동으로 디스크로 보내고, 자동으로 여러 CPU 코어에서 병렬로 정렬한다.

- 메모리 부족 없이 손쉽게 큰 데이터셋으로 확장 가능하다.

<br>

**[2] 유닉스 철학**

> *“다른 방법으로 데이터 처리가 필요할 때 정원 호스와 같이 여러 다른 프로그램을 연결하는 방법이 필요하다. 이것은 I/O 방식이기도 하다.”*
> - 더그 맥일로이(Doug McIlory), 유닉스 파이프 발명

1. 각 프로그램이 한 가지 일만 하도록 작성하라.
2. 모든 프로그램의 출력은 아직 알려지지 않은 다른 프로그램의 입력으로 쓰일 수 있다고 생각하라.
3. 소프트웨어를 빠르게 써볼 수 있게 설계하고 구축하라.
4. 프로그래밍 작업을 줄이려면 미숙한 도움보단 도구를 사용하라.

<br>

**1️⃣ 동일 인터페이스**

특정 프로그램이 다른 어떤 프로그램과도 연결 가능하려면 프로그램 모두가 같은 입출력 인터페이스를 사용해야 한다.

- 유닉스에서의 인터페이스는 단지 **순서대로 정렬된 바이트의 연속**인 `파일(파일 디스크립처)`이다.
- 파일은 단순해서 같은 인터페이스로 파일시스템의 실제 파일, 프로세스 간의 통신 채널, TCP 연결을 나타내는 소켓 등 다른 여러 가지 것을 표현할 수 있다.

<br>

> 🔉 ”**Everything is a file”**  
유닉스 시스템에서는 다양한 리소스를 모두 파일처럼 다루는 것처럼 설계되어 있다. 그러니까 어떠한 다른 시스템 자원이어도 동일한 함수를 사용할 수 있다는 것이다.


<br>

**2️⃣ 투명성과 실험**

> 유닉스 도구가 성공적인 이유 중 하나는 **진행 사항을 파악하기가 상당히 쉽기 때문**이다.
>
- 유닉스 명령에 들어가는 입력 파일은 일반적으로 불변으로 처리된다.
- 어느 시점이든 파이프라인을 중단하고 출력을 파이프를 통해 `less`로 보내 원하는 형태의 출력이 나오는지 확인할 수 있다.
- 특정 파이프라인 단계의 출력을 파일에 쓰고 그 파일을 다음 단계의 입력으로 사용할 수 있다.

⇒ 유닉스 도구를 사용하는 데 가장 큰 제약은 **단일 장비**에서만 실행된다느 점이다. 바로 이 점이 **하둡**같은 도구가 필요한 이유다.

<br>

### 맵리듀스와 분산 파일 시스템

> 맵리듀스는 유닉스 도구와 비슷한 면이 있지만 수천 대의 장비로 분산해서 실행이 가능하다는 점에서 차이가 있다.
>
- 맵리듀스 작업은 입력을 수정하지 않기 때문에 출력을 생산하는 것 외에 다른 부수 효과는 없다.
- 분산 파일 시스템 상의 파일을 입력과 출력으로 사용한다.
- 하둡 맵리듀스 구현에서 이 파일 시스템은 HDFS(Hadoop Distributed File System)라고 하는데 GFS(Google File System)를 재구현한 오픈소스다.
- HDFS는 비공유 원칙을 기반으로 하는데 NAS(Network Attached Storage)와 SAN(Storage Area Network) 아키텍처에서 사용하는 공유 디스크 방식과는 반대다.
- 공유 디스크 저장소는 중앙 집중 저장 장치를 사용하는 데 맞춤형 하드웨어를 사용하거나 파이버 채널(Fibre Channel)과 같은 특별한 네트워크 인프라를 사용하기도 한다.
- 반면 비공유 방식은 특별한 하드웨어가 필요없다. 일반적인 데이터센터 네트워크에 연결된 컴퓨터면 충분하다.
- HDFS는 개념적으로는 매우 큰 하나의 파일 시스템이고 데몬이 실행 중인 모든 장비의 디스크를 사용할 수 있다.
    - HDFS는 각 장비에서 실행되는 데몬 프로세스로 구성된다.
    - 데몬 프로세는 다른 노드가 해당 장비에 저장된 파일에 접근 가능하게끔 네트워크 서비스를 제공한다.
    - 네임노드(NameNode)라고 부르는 중앙 서버는 특정 파일 블록이 어떤 장비에 저장됐는지 추적한다.
- 장비가 죽거나 디스크가 실패하는 경우에 대비하기 위해 파일 블록은 여러 장비에 복제된다.
    - 단순히 여러 장비에 동일한 데이터를 복사하는 방식
    - 리드 솔로몬 코드(Read-Solomon code) 같은 삭제 코딩(erasure coding) 방식을 사용해 데이터 전체를 복제하는 것보다 적은 저장소 부담으로 손실된 데이터를 복구하는 방식
- HDFS는 확장성이 뛰어나다.

<br>

**[1] 맵리듀스 작업 실행하기**

> 맵리듀스는 HDFS 같은 분산 파일 시스템 위에서 대용량 데이터셋을 처리하는 코드를 작성하는 프로그래밍 프레임워크다.
>

**맵 리듀스의 데이터 처리 패턴**

1단계. 파일을 나누어 레코드를 만든다.

2단계. 각 입력 레코드마다 매퍼 함수를 호출해 키와 값을 추출한다. (맵)

3단계. 키를 기준으로 키-값 쌍을 모두 정렬한다.

4단계. 리듀스 함수를 호출한다. (리듀스)

**두 가지 콜백 함수** 

맵리듀스 프레임워크는 `매퍼`가 생산한 키-값 쌍을 받아 같은 키를 가진 레코드를 모으고 해당 값의 집합을 반복해 `리듀서` 함수를 호출한다.

| 매퍼(Mapper) | 리듀서(Reducer) |
| --- | --- |
| 입력 레코드로부터 키와 값을 추출 (정렬에 적합한 형태로 데이터를 준비하는 역할) | 출력 레코드 생산 (정렬된 데이터를 가공하는 역할) |

<br>

**1️⃣ 맵리듀스의 분산 실행**

> 맵리듀스 작업의 병렬 실행은 `파티셔닝`을 기반으로 한다. 작업 입력으로 `HDFS`상의 디렉터리를 사용하는 것이 일반적이고, 입력 디렉터리 내 각 파일 또는 파일 블록을 독립된 `맵 태스크`에서 처리할 독립 파티션으로 간주한다.
>


- 맵 태스크 수는 입력 파일의 블록 수로 결정되지만 리듀스 태스크 수는 사용자가 설정한다.
- 특정 키-값 쌍이 어느 리듀스 태스크에서 수행될지 결정하기 위해 키의 해시값을 사용한다.
- 정렬 : 각 맵 태스크는 키의 해시값을 기반으로 출력을 리듀서로 파티셔닝하고, 각 파티션을 매퍼의 로컬 디스크에 정렬된 파일로 기록한다.
- `셔플(suffle)` : 리듀서를 기준으로 파티셔닝하고 정렬한 뒤 매퍼로부터 데이터 파티션을 복사하는 과정

<br>

**2️⃣ 맵 리듀스 워크플로**

> 맵리듀스 작업 하나로 해결할 수 있는 문제의 범위는 제한적이라 각 작업을 연결해 워크플로(workflow)로 구성하는 방식은 꽤 일반적이다.
>
- 연결된 맵리듀스 작업은 각 명령의 출력을 임시 파일에 쓰고 다음 명령이 그 임시 파일로부터 입력을 읽는 방식에 더 가깝다.
- 워크플로 상에서 선행 작업이 완전히 끝나야만 다음 작업을 시작할 수 있어 하둡 맵리듀스 작업 간 수행 의존성을 관리하기 위해 다양한 스케줄러가 개발됐다.
- 피그(Pig), 하이브(Hive) 등과 같은 다양한 하둡용 고수준 도구는 다중 맵리듀스를 서로 적절하게 자동으로 엮어 워크플로를 설정한다.

<br>

**[2] 리듀스 사이드 조인과 그룹화**

일괄 처리 맥락에서 조인은 데이터셋 내 모든 연관 관계를 다룬다는 뜻이다. 여러 장비에 걸쳐 병렬 처리가 가능한 경우는 입력 전체를 스캔하는 것이 상당히 합리적이다.

<br>

**1️⃣ 사용자 활동 이벤트 분석 예제**

- 나쁜 예 : 하나씩 활동 이벤트를 훑으며 나오는 사용자 ID 마다 DB 질의 보내기
    - 질의 통신으로 인한 왕복 시간으로 처리량 제한, 많은 질의 병렬 실행으로 데이터베이스 과부하
- 좋은 예 : 사용자 데이터베이스의 사본을 가져와 사용자 활동 레코드가 저장된 분산 파일 시스템에 넣기

<br>

**2️⃣ 정렬 병합 조인**

- 키로 매퍼의 출력을 파티셔닝해 키-값 쌍으로 정렬한다면 같은 사용자의 활동 이벤트와 사용자 레코드는 리듀서의 입력으로 서로 인접해서 들어간다.
- `보조 정렬(secondary sort)` : 리듀서가 사용자 데이터베이스를 먼저 보고 활동 이벤트를 시간 순으로 보게하는 식으로 작업 레코드를 재배열 하는 것
- 정렬 병합 조인(sort-merge join) : 조인의 양측의 정렬된 레코드 목록을 병합

<br>

**3️⃣ 같은 곳으로 연관된 데이터 가져오기**

- 병합 정렬 조인 중 매퍼와 정렬 프로세스는 특정 사용자 ID로 조인 연산을 할 때 필요한 모든 데이터를 한 곳으로 모은다. 그래서 사용자 ID별로 리듀서를 한 번만 호출한다.
    - 처리량 UP, 메모리 부담 LOW
- 맵리듀스 프로그래밍 모델은 올바른 장비로 데이터를 모으는 연산의 물리적 네트워크 통신 측면과 받은 데이터를 처리하는 애플리케이션 로직을 분리한다.

<br>

**4️⃣ 쏠림 다루기** 

> 조인 입력에 핫 키(hot key)가 존재하는 경우에 핫스팟을 완화할 방법은 무엇인가?
>
- 피그(Pig)의 쏠린 조인(skewed join) 메서드
    - 어떤 키가 핫 키인지 결정하기 위해 샘플링 작업 수행
    - 실제 조인을 수행할 때 매퍼는 핫 키를 가진 레코드는 여러 리듀서 중 임의로 선택한 하나로 레코드를 보낸다. 핫 키로 조인할 다른 입력은 핫 키각 전송된 모든 리듀서에 복제한다.
    - 비용이 들지만 병렬화 효과가 훨씬 큼
- 크런치(Crunch)의 공유 조인(shared join) 메서드
    - 핫 키를 명시적으로 지정한다.
- 하이브(Hive)
    - 핫 키는 테이블 메타데이터에 명시적으로 지정하고 핫 키와 관련된 레코드를 나머지 키와는 별도 파일에 저장한다.
    - 해당 테이블에서 조인할 때 핫 키를 가지는 레코드는 맵 사이드 조인(map-side join)을 사용해 처리한다.
- 핫 키로 레코드를 그룹화하고 집계하는 작업
    - 첫 번째 맵리듀스 단계. 레코드를 임의의 리듀서로 보낸다. 각 리듀서는 핫 키 레코드의 일부를 그룹화하고 키별로 집계해 간소화한 값을 출력한다.
    - 두 번째 맵리듀스 작업. 첫 단계 모든 리듀서에서 나온 값을 키별로 모두 결합해 하나의 값으로 만든다.

<br>

**[3] 맵 사이드 조인**

| 방법 | 리듀스 사이드 조인(reduce-side join) | 맵사이드 조인(map-side join) |
| --- | --- | --- |
| 정의 | 실제 조인 로직을 리듀서에서 수행 | 입력 데이터에 대해 특정 가능일 가능할 때 사용할 수 있는 축소된 맵리듀스 작업 |
| 장점 | 입력 데이터에 대한 특정 가정이 필요없다. | 빠른 조인 수행이 가능하다. |
| 단점 | 정렬 후 리듀서로 복사한 뒤 리듀서 입력을 병합하는 모든 과정에 드는 비용이 크다. |  |

<br>

**1️⃣ 브로드캐스트 해시 조인(broadcast hash join)**

- 큰 입력의 파티션 하나를 담당하는 각 매퍼는 작은 입력 전체를 읽는다.
- 작은 조인 입력을 인메모리 해시 테이블로 적재하는 대신 로컬 디스크에 읽기 전용 색인으로 저장하기도 한다.

