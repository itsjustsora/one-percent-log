## 12. 데이터 시스템의 미래

<br>

**[개념 사전]** 

| 단어 | 의미 |
| --- | --- |
| 전체 순서 브로드캐스트 | 이벤트의 전체 순서를 결정하는 것 |
| 결정적 함수(deterministic function) | 입력이 같으면 항상 같은 출력을 내는 함수 |
| 미분 데이터플로(different dataflow) | 데이터가 흐르는 과정에서 발생하는 연산을 미분(변화율 측정)할 수 있는 시스템 |
| 오프라인 우선(offline-first) 애플리케이션 | 인터넷이 없어도 잘 작동하도록 설계된 앱 |
| 이벤트소스(EventSource) API | 웹 브라우저에서 서버로부터 실시간으로 데이터를 일방향으로 수신할 수 있도록 하는 JavaScript API |
| 종단 간 논증(end-to-end argument) | 어떤 기능을 시스템 내부에서 복잡하게 구현하더라도, 진짜 최종 사용자 단(End) 에서 검증하거나 처리해야만 정확성과 신뢰성을 보장할 수 있다는 원리 |

<br>

## 새롭게 알게 된 점 (New)

### 데이터 통합

> 데이터를 사용하는 모든 다른 상황에 적합한 소프트웨어가 있을 가능성은 낮다. 그래서 원하는 애플리케이션 기능을 제공하기 위해서는 반드시 여러 다른 소프트웨어를 함께 엮어 사용해야 한다.
>

<br>

**[1] 파생 데이터에 특화된 도구의 결합**

> 데이터를 다루는 범위는 어지러울 정도로 넓다. 어떤 사람에게는 애매하거나 의미 없는 기능이 다른 사람에게는 핵심 요구사항일 수 있다. 데이터 통합의 필요성은 나무가 아닌 숲을 보기 위해 줌아웃해서 조직 전체 데이터플로를 고려할 때야 비로소 명확해진다.
>
- 데이터를 다른 방식으로 표현하는 수가 늘어날수록 데이터 시스템을 통합하기가 더욱 어렵다.

<br>

**1️⃣ 파생 데이터 대 분산 트랜잭션**

|  | 파생 데이터 | 분산 트랜잭션 |
| --- | --- | --- |
| 순서 결정 수단 | 로그 | 상호 배타적인 잠금 |
| 변경 효과 보장 | 결정적 재시도, 멱등성 | 원자적 커밋 |
| 선형성 지원 | ❌ (비동기 갱신) | ⭕️ |
- `선형성`은 `자신이 쓴 내용 읽기` 같은 유용한 기능을 보장해준다.

<br>

> 🔉 저자는 훌륭한 분산 트랜잭션 프로토콜이 널리 지원되지 않는 상태에서는 `로그 기반 파생 데이터`가 **이종 데이터 시스템을 통합하는 가장 장래성 있는 접근법이라고 생각한다**고 했다. 하지만 분산 트랜잭션에서 `자신이 쓴 내용 읽기`를 보장하는 것은 여전히 유용하다고 한다.


<br>

2️⃣ 전체 순서화의 제약

> **규모가 크고 복잡한 작업부하가 발생할 때 이벤트 로그의 순서 전체를 보장하는 것의 한계**
>
- 이벤트의 처리량이 단일 장비에서 처리할 수 있는 양보다 커지며 복수의 장비로 파티셔닝을 해야 한다. ➡️ 두 이벤트의 순서 애매해짐
- 서버가 여러 지역의 데이터센터에 걸쳐있다면(독립적인 리더), 각 데이터센터에서 나온 이벤트는 서로 순서가 정해지지 않는다.
- 마이크로서비스로 배포한다면, 두 이벤트가 서로 다른 서비스에서 발생했다면 이들 사이에는 정해진 순서가 없다.

<br>

**[1] 일괄 처리와 스트림 처리**

> 데이터 통합의 목표는 데이터를 올바른 장소에 올바른 형태로 두는 것이다.
>

**1️⃣ 파생 상태 유지**

- `결정적 함수`의 원리는 `내결함성`에 도움이 될 뿐 아니라 **조직 내의 데이터플로 추론을 단순화**한다.
- `이벤트 로그 기반 시스템`의 **비동기 방식**은 시스템 일부의 결함이 국소적으로 남아있어 시스템을 견고하게 만든다.
- `색인`을 **비동기 방식**으로 유지한다면 파티션 간 통신에서 더욱 `신뢰성` 있고 `확장성`이 좋아진다.

<br>

2️⃣ **애플리케이션 발전을 위한 파생 데이터 재처리**

- `스트림 처리`로 입력의 변화를 빠르게 파생 뷰에 반영할 수 있다.
- `일괄 처리 시스템`으로 누적된 상당한 양의 과거 데이터를 재처리해 기존 데이터셋을 반영한 새 파생 뷰를 만들 수 있다.
- **파생 뷰를 통한 점진적 발전**
    - 기존 뷰와 새 뷰를 유지하면서 사용자들에게 새 뷰를 점점 노출시켜 기존 뷰를 내릴 수 있게 한다.
    - 기존 뷰를 유지하기 때문에, 쉽게 이전으로 되돌릴 수 있다는 장점이 있다.

<br>

**3️⃣ 람다 아키텍처**

> 🤔 *일괄 처리를 과거 데이터를 재처리하는 데 사용하고 스트림 처리를 최근 갱신 데이터를 처리하는 데 사용한다고 할 때 어떻게 두 방식을 조합해 사용할 수 있을까?*
`람다 아키텍처(lambda architecture)`는 이 분야에서 많은 관심을 받은 제안이다.
>
- 람다 아키텍처는 **두 개의 다른 시스템을 병행해서 운용하기를 제안**한다. (하둡 맵리듀스 같은 일괄 처리 시스템과 스톰 같은 분리된 스트림 처리 시스템 함께 운용)

**➀ 설계 배경**

|  | 일괄 처리 | 스트림 처리 |
| --- | --- | --- |
| 알고리즘 | 느리고 정확한 알고리즘을 사용한다. | 빠른 근사 알고리즘을 사용한다. |
| 특징 | 간단해서 버그가 생길 가능성이 적다. | 신뢰성이 떨어지고 내결함성을 확보하기 어렵다. |

<Br>

**➁ 접근법**

- 스트림 처리자는 이벤트를 소비해 근사(approximate) 갱신을 뷰에 빠르게 반영한다.
- 일괄 처리자가 같은 이벤트 집합을 소비해 정확한 버전의 파생 뷰에 반영한다.

<br>

**➂ 문제점**

- 일괄 처리와 스트림 처리 프레임워크 모두 같은 로직을 유지하기 복잡하다.
- 두 출력을 병합할 때 연산이 복잡하다면 난이도가 높아진다.
- 대용량 데이터에서 전체 과거 데이터를 재처리한다면 비용이 많이 발생한다. (대안으로 활용하는 증분으로 일괄 처리 시에도 낙오자 처리 문제 등 발생)

<br>

> 🔉 최신에는 같은 시스템 내에서 일괄 처리 연산(과거 데이터 재처리)과 스트림 연산(이벤트가 도착하는대로 처리)을 모두 구현함으로써 람다 아키텍처의 장점만 취할 수 있게 하는 작업이 진행되고 있다.


<br>

### 데이터베이스 언번들링

**[1] 데이터 저장소 기술 구성하기**

**1️⃣ 모든 것의 메타데이터베이스**

> 모든 접근 패턴에 적합한 단일 데이터 모델이나 저장 형식이 없다고 전제해 보자. 나는 서로 다른 저장소와 처리 도구를 사용하지만 하나의 응집된 시스템으로 구성할 수 있는 두 가지 길이 존재한다고 생각한다.
>

|  | 연합 데이터베이스 | 언번들링 데이터베이스 |
| --- | --- | --- |
| 통합 구분 | 읽기 | 쓰기 |
| 특징 | 많은 하단 저장소 엔진과 처리 메서드를 통합해 질의하는 인터페이스 제공 | 통일된 저수준 API(파이프)를 통해 통신  |
| 기술 예시 | postgreSQL의 외래 데이터 랩(foreign data wrapper) | - |
| 장점 | 고수준 질의 언어와 우아한 시맨틱 사용 | - |
| 단점 | 구현 복잡, 쓰기 동기화 문제 | - |

<Br>

**2️⃣ 언번들링**

> 쓰기를 동기화하는 전통적인 접근법은 이종 저장소 시스템 간 분산 트랜잭션이 필요하다. 하지만 데이터가 다른 기술 사이의 경계를 오간다면 멱등성을 기반으로 쓰기를 수행하는 비동기 이벤트 로그를 사용하는 편이 훨씬 더 강력하고 현실적인 접근법이라고 본다.
>
- 로그 기반 통합의 큰 장점은 **다양한 구성 요소 간** `느슨한 결합(loose coupling)`이다.
- 언번들링의 목표는 몇 개의 다른 데이터베이스를 결합해 단일 소프트웨어로 가능한 것보다 더 넓은 범위의 작업부하에 대해 좋은 성능을 달성하는 것이다.
- 유닉스 셸과 동일한 언번들링된 데이터베이스는 존재하지 않는다.

<br>

**[2] 데이터플로 주변 애플리케이션 설계**

> 모든 소프트웨어가 특정 언어와 프레임워크 또는 도구만을 사용해 개발될 것으로 기대하는 것은 비현실적이다.
>

<br>

**1️⃣ 데이터플로: 상태 변경과 애플리케이션 코드 간 상호작용**

> 데이터플로 측면에서 애플리케이션을 생각한다는 것은 애플리케이션 코드와 상태 관리 간의 관계를 재조정한다는 의미다.
>
- 애플리케이션 코드는 어떤 곳에서 상태 변화를 트리거해 다른 곳의 상태 변화에 응답한다.
- 애플리케이션 코드로 데이터베이스에 내장된 파생 함수가 일반적으로 지원하지 않는 임의 처리가 가능하다.

<br>

**2️⃣ 스트림 처리자와 서비스**

> 예를 들어, 한 소비자가 특정 통화로 가격이 매겨진 상품을 구매했지만 지불은 다른 통화로 했다고 가정하자. 일단 통화 변환을 하기 위해서는 환율을 알아야 한다.
>

| 접근법 | 마이크로서비스 | 데이터플로 |
| --- | --- | --- |
| 구매 처리 코드 | 특정 통화의 현재 환율을 얻기 위해 환율 서비스나 데이터베이스에 질의 | 미리 환율 갱신 스트림을 구독하고 환율이 바뀔 때마다 로컬 데이터베이스에 환율 기록 후 로컬 데이터베이스에 질의 |
- 데이터플로 접근법은 다른 서비스로 보내는 동기식 네트워크 요청을 로컬 데이터베이스 질의로 교체해서 훨씬 빠르며, 다른 서비스 장애에도 잘 버틸 수 있다.

<br>

> 🏷️ *가장 빠르고 가장 신뢰성 있는 네트워크 요청은 네트워크 요청을 전혀 하지 않는 것이다.*


<br>

**[3] 파생 상태 관찰하기**

> 파생 데이터셋은 쓰기 시간에 필요한 작업의 양과 읽기 시간에 필요한 작업의 양 간에 트레이드오프를 나타낸다.
>
- `쓰기 경로(write path)` : 시스템에 정보를 기록할 때마다 일괄 처리와 시스템 처리의 여러 단계를 거친 다음 결과적으로 기록된 데이터를 모든 파생 데이터셋에 통합해 갱신하는 과정
- `읽기 경로(write path)` : 사용자 요청을 처리할 때 파생 데이터셋을 읽고 그 결과를 어느정도 가공한 후에 사용자 응답을 만드는 과정

<br>

### 정확성을 목표로

> 전통적인 트랜잭션 접근법이 사라지고 있지는 않지만 나는 이것이 애플리케이션을 정확하게 만들고 결함에 견딜 수 있게 하는 최후의 방법이라고 믿지는 않는다. 이번 절에서 나는 데이터플로 아키텍처의 맥락에서 정확성에 관해 생각하는 몇 가지 방법을 제안한다.
>

<br>

**[1] 데이터베이스에 관한 종단 간 논증**

> 불변성과 추가 전용 데이터를 지지하는 것은, 결함이 있는 코드 때문에 좋은 데이터를 파괴하게 되는 능력을 제거한다면 그런 실수로부터 복구하기가 쉬워지기 때문이다.
*불변성이 유용하긴 해도 그 자체가 만능은 아니다.*
>

<br>

**1️⃣ 데이터 손상 사례**

**두 번 처리 (정확히 한 번 시맨틱 보장 불가)**

> 네트워크 장애 등과 같은 이유로 연산이 두 번 이상 처리된다면?
>
- **해결법** : 멱등성을 보장해서 같은 결과가 나오도록 하자.
- **주의점** : 한 노드에서 다른 노드로 장애 복구될 때 펜싱을 보장해야 한다.


**중복 트랜잭션**

> TCP 프로토콜의 중복 억제 범위를 벗어난 상황에서 같은 트랜잭션 요청이 여러 번 처리된다면?
>
- 시스템 차원으로 `2단계 커밋`을 활용해 네트워크 장애 이후 의심스러운 트랜잭션이 커밋됐는지 어보트됐는지 확인하여 해결한다.
- 별개로, 네트워크 장애로 최종 사용자 클라이언트에 에러 메시지가 전해지면 수동으로 재시도하여 문제가 발생할 수 있다.

<br>

**2️⃣** 종단 간 사고를 데이터 시스템에 적용하기

> 애플리케이션이 직렬성 트랜잭션과 같은 비교적 강력한 안전성 속성을 지원하는 데이터 시스템을 사용한다는 이유만으로 데이터 손실 및 손상이 발생하지 않는다고 할 수 없다. 애플리케이션 자체가 중복 억제와 같은 **종단 간 대책**을 갖춰야 한다.
>
