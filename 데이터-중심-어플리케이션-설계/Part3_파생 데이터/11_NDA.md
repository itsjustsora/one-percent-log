> *복잡하지만 잘 작동하는 시스템은 예외 없이 간단하지만 잘 작동하는 시스템으로부터 발전한다.
이 명제는 역도 참이다.
처음부터 복잡하게 설계된 시스템은 절대 작동할 리도 없고 작동하게 만들지도 못한다.*
**존 갈, 체계론(1975)**
>

<br>

**[스트림 처리의 기본 개념]**

고정된 시간 조각이라는 개념을 버리고 단순히 이벤트가 발생할 때마다 처리한다.

<br>

**[개념 사전]**

| 단어 | 의미 |
| --- | --- |
| 이벤트 스트림 | 일괄 처리 데이터와는 반대로 한정되지 않고 점진적으로 처리되는 데이터 관리 메커니즘 |


<br>

## 새롭게 알게 된 점 (New)

### 이벤트 스트림 전송

> 🤔 일괄 처리 환경에서 작업은 입출력이 파일이다. 그러면 스트림 처리에서는 어떨까?
>
- 이벤트는 텍스트 문자열이나 JSON 또는 이진 형태 등으로 부화되며 이 과정을 통해 저장할 수 있다.
- `생산자(producer, 발행자(publisher), 발송자(sender))`가 이벤트를 만들면 **복수**의 `소비자(consumer, 구독자(subscriber) 또는 수신자(recipient))`가 처리할 수 있다.
- 파일 시스템에서는 관련 레코드 집합을 파일 이름으로 식별하지만 스트림 시스템에서는 대개 `토픽(topic)`이나 `스트림`으로 관련 이벤트를 묶는다.

<br>

**[1] 메시징 시스템(messaging system)**

> 🤔 생산자가 소비자가 메시지를 처리하는 속도보다 빠르게 전송하다면 어떻게 될까?
>

**시스템이 할 수 있는 선택지**

- 메시지를 버린다.
- 큐에 메시지를 버퍼링한다.
- `배압`을 적용해서 생산자가 메시지를 더 보내지 못하게 막는다.

<Br>

> 🔉 메시지가 큐에 버퍼링될 때 큐 크기가 메모리 크기보다 커지면 시스템이 중단되는지, 메시지를 디스크에 쓰는지, 디스크에 쓴다면 디스크 접근이 시스템의 성능에 어떤 영향을 주는지까지 이해하는 것이 중요하다.


<Br>

**1️⃣ 직접 메시징 시스템**

- 많은 메시지 시스템은 중간 노드를 통하지 않고 생산자와 소비자를 네트워크로 직접 통신한다.
- 직접 메시징 시스템은 설계 상황에서는 잘 동작하지만 메시지가 유실될 가능성을 고려해서 애플리케이션 코드를 작성해야 한다.
- 일부 프로토콜은 실패한 메시지 전송을 생산자가 재시도하게끔 하지만 생산자 장비가 죽어버리면 재시도하려고 했던 메시지 버퍼를 잃어버릴 수 있기 때문에 문제가 있다.

<br>

> 🔉 **UDP 멀티캐스트**는 낮은 지연이 필수인 주식 시장과 같은 금융 산업에서 널리 사용된다. UDP 자체는 신뢰성이 낮아도 애플리케이션 단의 프로토콜은 읽어버린 패킷을 복구할 수 있다.

<br>

**2️⃣ 메시지 브로커**

> **직접 메시징 시스템의 대안**으로 널리 사용된다. 근본적으로 메시지 스트림을 처리하는 데 최적화된 데이터베이스의 일종이다.
>
- 브로커가 장애로 중단됐을 때 메시지를 잃어버리지 않기 위해 디스크에 메시지를 기록할 수 있다. (혹은 메모리에만)
- 소비 속도가 느린 소비자가 있으면 일반적으로 큐가 제한 없이 계속 늘어나게 한다.
- **비동기 동작** : 생산자가 메시지를 보낼 때 생산자는 브로커가 해당 메시지를 버퍼에 넣었는지만 확인, 소비자가 메시지를 처리하기까지 기다리지 않는다.

<br>

**3️⃣ 메시지 브로커 vs. 데이터베이스**

| 구분 | 메시지 브로커 | 데이터베이스 |
| --- | --- | --- |
| 데이터 삭제 시점 | 소비자에게 데이터 배달이 성공할 경우 | 데이터가 삭제될 경우 |
| 데이터 검색 | 특정 패턴과 부합하는 토픽의 부분 집합 구독 방식 지원 | 보조 색인 및 다양한 방법 지원 |
| 질의  결과 | 데이터가 변하면 클라이언트에게 알림 |                                                  질의 시점의 데이터 스냅숏 기준 |

<br>

**4️⃣ 복수 소비자**

복수 소비자가 같은 토픽에서 메시지를 읽을 때 사용하는 주요 패턴 두 가지

<br>

**5️⃣ 확인 응답과 재전송**

- 메시지를 유실하지 않기 위해 메시지 브로커는 확인 응답을 사용한다.
- 메시지 브로커는 JMS와 AMQP 표준에서 요구하는 대로 메시지 순서를 유지하려 노력할지라도 부하 균형 분산과 메시지 재전송을 조합하면 필연적으로 메시지 순서가 변경된다.

<br>

**[2] 파티셔닝된 로그**

> **데이터베이스의 지속성 있는 저장 방법**과 **메시징 시스템의 지연 시간이 짧은 알림 기능**을 조합할 수 없을까? 이것이 `로그 기반 메시지 브로커(log-based message broker)`의 기본 아이디어어다.
>

<br>

**1️⃣ 로그를 사용한 메시지 저장소**

> 생산자가 보낸 메시지는 로그 끝에 추가하고 소비자는 로그를 순차적으로 읽어 메시지를 받는다. 소비자가 로그 끝에 도달하면 새 메시지가 추가됐다는 알림을 기다린다.
>
- 디스크 하나를 쓸 때보다 처리량을 높이기 위해 확장하는 방법으로 로그를 파티셔닝하기도 한다.
- 각 파티션은 다른 파티션과 독립적으로 읽고 쓰기가 가능한 분리된 로그가 된다.
- `토픽`은 같은 형식의 메시지를 전달하는 파티션들의 그룹으로 정의한다.

<br>

**로그 기반 메시지 브로커**

*아파치 카프카(Apache Kafka), 아마존 키네시스 스트림(Amazon Kinesis Stream), 트위터의 분산 로그(DistributiedLog)*

- 각 파티션 내에서 브로커는 모든 메시지에 `오프셋(단조 증가하는 순번)`을 부여한다.
- 모든 메시지를 디스크에 저장하지만 여러 장비에 메시지를 파티셔닝해 초당 수백만 개의 메시지를 처리할 수 있고, 메시지를 복제함으로써 장애에 대비할 수 있다.

<br>

**2️⃣ 로그 방식 vs. 전통적인 메시징 방식**

|  | 장점                                                                  | 단점 |
| --- |---------------------------------------------------------------------| --- |
| 로그 기반 시스템 | ❶ 여러 소비자가 독립적으로 로그 읽기 가능 (팬 아웃 처리)<br>❷ 메시지 읽기 순서 보장<br>❸ 메시지 유지 가능 | ❶ 개별 메시지가 아닌 파티션 단위로 할당 *(메시지 단위 병렬 처리 어려움)*<br>❷ 작업을 공유하는 노드 수 ≤ 해당 토픽의 로그 파티션 수 제한<br>❸ 특정 메시지 지연 시 후속 메시지 처리까지 지연 |

🤔 메시지를 처리하는 비용이 비싸고 메시지 단위로 병렬화 처리하고 싶지만 메시지 순서는 중요하지 않다면?

→ `JMS/AMQP 방식`

🤔 처리량이 많고 메시지를 처리하는 속도가 빠르지만 메시지 순서가 중요하다면?

→ `로그 기반 접근법`

<br>

**3️⃣ 소비자 오프셋**

> 파티션 하나를 순서대로 처리했을 때의 장점
>
- 브로커는 주기적으로 소비자 오프셋을 기록하면 될뿐, 모든 개별 메시지마다 보내는 확인 응답을 추적하지 않아도 된다.
- 추적 오버헤드 감소 | 일괄 처리, 파이프라이닝 수행 기회 제공 → **로그 기반 시스템의 처리량 확장**
- 소비자 노드에 장애가 발생하면 마지막 기록된 오프셋부터 메시지를 처리한다.

<br>

**4️⃣ 디스크 공간 사용**

- `원형 버퍼(circular buffer)` or `링 버퍼(ring buffer)` : 로그는 크기가 제한된 버퍼로 구현하고 버퍼가 가득 차면 오래된 메시지 순서대로 버린다.
- 메시지 보관 기간과 관계없이 모든 메시지를 디스크에 기록하기 때문에 로그 처리량은 일정하다.

<br>

**5️⃣ 소비자가 생산자를 따라갈 수 없을 때**

- 소비자의 로그의 헤드로부터 얼마나 떨어졌는지 모니터링하면 눈에 띄게 뒤처지는 경우 경고할 수 있다.
- 어떤 소비자가 너무 뒤처져서 메시지를 잃기 시작해도 해당 소비자만 영향을 받고 다른 소비자들의 서비스를 망치지 않기 때문에 운영상 상당히 유리하다.
- 소비자가 종료되거나 죽으면 자원소비가 중단되고 소비자 오프셋만 남는다.
    - 전통적인 브로커의 경우 해당 소비자가 사용하던 큐를 삭제해줘야 한다.

<br>

**6️⃣ 오래된 메시지 재생**

- 메시지를 소비하는 것은 로그를 변화시키지 않는 읽기 전용 연산이다.
- 유일한 부수 효과는 `소비자 오프셋 이동`으로, 처리 코드를 변경해 특정 분량의 메시지를 재처리할 수 있다.
- 로그 기반 메시징 시스템은 이처럼 많은 실험을 할 수 있고 오류가 버그를 복구하기 쉽다.
